/* automatically generated by rust-bindgen 0.59.2 */

pub const ROARING_VERSION_MAJOR: ::std::os::raw::c_uint = 0;
pub const ROARING_VERSION_MINOR: ::std::os::raw::c_uint = 3;
pub const ROARING_VERSION_REVISION: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = " Roaring arrays are array-based key-value pairs having containers as values"]
#[doc = " and 16-bit integer keys. A roaring bitmap  might be implemented as such."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring_array_s {
    pub size: i32,
    pub allocation_size: i32,
    pub containers: *mut *mut ::std::os::raw::c_void,
    pub keys: *mut u16,
    pub typecodes: *mut u8,
    pub flags: u8,
}
#[test]
fn bindgen_test_layout_roaring_array_s() {
    assert_eq!(
        ::std::mem::size_of::<roaring_array_s>(),
        40usize,
        concat!("Size of: ", stringify!(roaring_array_s))
    );
    assert_eq!(
        ::std::mem::align_of::<roaring_array_s>(),
        8usize,
        concat!("Alignment of ", stringify!(roaring_array_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<roaring_array_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_array_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<roaring_array_s>())).allocation_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_array_s),
            "::",
            stringify!(allocation_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<roaring_array_s>())).containers as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_array_s),
            "::",
            stringify!(containers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<roaring_array_s>())).keys as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_array_s),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<roaring_array_s>())).typecodes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_array_s),
            "::",
            stringify!(typecodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<roaring_array_s>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_array_s),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " Roaring arrays are array-based key-value pairs having containers as values"]
#[doc = " and 16-bit integer keys. A roaring bitmap  might be implemented as such."]
pub type roaring_array_t = roaring_array_s;
pub type roaring_iterator = ::std::option::Option<
    unsafe extern "C" fn(value: u32, param: *mut ::std::os::raw::c_void) -> bool,
>;
pub type roaring_iterator64 = ::std::option::Option<
    unsafe extern "C" fn(value: u64, param: *mut ::std::os::raw::c_void) -> bool,
>;
#[doc = "  (For advanced users.)"]
#[doc = " The roaring_statistics_t can be used to collect detailed statistics about"]
#[doc = " the composition of a roaring bitmap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring_statistics_s {
    pub n_containers: u32,
    pub n_array_containers: u32,
    pub n_run_containers: u32,
    pub n_bitset_containers: u32,
    pub n_values_array_containers: u32,
    pub n_values_run_containers: u32,
    pub n_values_bitset_containers: u32,
    pub n_bytes_array_containers: u32,
    pub n_bytes_run_containers: u32,
    pub n_bytes_bitset_containers: u32,
    pub max_value: u32,
    pub min_value: u32,
    pub sum_value: u64,
    pub cardinality: u64,
}
#[test]
fn bindgen_test_layout_roaring_statistics_s() {
    assert_eq!(
        ::std::mem::size_of::<roaring_statistics_s>(),
        64usize,
        concat!("Size of: ", stringify!(roaring_statistics_s))
    );
    assert_eq!(
        ::std::mem::align_of::<roaring_statistics_s>(),
        8usize,
        concat!("Alignment of ", stringify!(roaring_statistics_s))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<roaring_statistics_s>())).n_containers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_statistics_s),
            "::",
            stringify!(n_containers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<roaring_statistics_s>())).n_array_containers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_statistics_s),
            "::",
            stringify!(n_array_containers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<roaring_statistics_s>())).n_run_containers as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_statistics_s),
            "::",
            stringify!(n_run_containers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<roaring_statistics_s>())).n_bitset_containers as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_statistics_s),
            "::",
            stringify!(n_bitset_containers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<roaring_statistics_s>())).n_values_array_containers as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_statistics_s),
            "::",
            stringify!(n_values_array_containers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<roaring_statistics_s>())).n_values_run_containers as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_statistics_s),
            "::",
            stringify!(n_values_run_containers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<roaring_statistics_s>())).n_values_bitset_containers as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_statistics_s),
            "::",
            stringify!(n_values_bitset_containers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<roaring_statistics_s>())).n_bytes_array_containers as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_statistics_s),
            "::",
            stringify!(n_bytes_array_containers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<roaring_statistics_s>())).n_bytes_run_containers as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_statistics_s),
            "::",
            stringify!(n_bytes_run_containers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<roaring_statistics_s>())).n_bytes_bitset_containers as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_statistics_s),
            "::",
            stringify!(n_bytes_bitset_containers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<roaring_statistics_s>())).max_value as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_statistics_s),
            "::",
            stringify!(max_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<roaring_statistics_s>())).min_value as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_statistics_s),
            "::",
            stringify!(min_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<roaring_statistics_s>())).sum_value as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_statistics_s),
            "::",
            stringify!(sum_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<roaring_statistics_s>())).cardinality as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_statistics_s),
            "::",
            stringify!(cardinality)
        )
    );
}
#[doc = "  (For advanced users.)"]
#[doc = " The roaring_statistics_t can be used to collect detailed statistics about"]
#[doc = " the composition of a roaring bitmap."]
pub type roaring_statistics_t = roaring_statistics_s;
pub type size_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring_bitmap_s {
    pub high_low_container: roaring_array_t,
}
#[test]
fn bindgen_test_layout_roaring_bitmap_s() {
    assert_eq!(
        ::std::mem::size_of::<roaring_bitmap_s>(),
        40usize,
        concat!("Size of: ", stringify!(roaring_bitmap_s))
    );
    assert_eq!(
        ::std::mem::align_of::<roaring_bitmap_s>(),
        8usize,
        concat!("Alignment of ", stringify!(roaring_bitmap_s))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<roaring_bitmap_s>())).high_low_container as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_bitmap_s),
            "::",
            stringify!(high_low_container)
        )
    );
}
pub type roaring_bitmap_t = roaring_bitmap_s;
extern "C" {
    #[doc = " Dynamically allocates a new bitmap (initially empty)."]
    #[doc = " Returns NULL if the allocation fails."]
    #[doc = " Capacity is a performance hint for how many \"containers\" the data will need."]
    #[doc = " Client is responsible for calling `roaring_bitmap_free()`."]
    pub fn roaring_bitmap_create_with_capacity(cap: u32) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Initialize a roaring bitmap structure in memory controlled by client."]
    #[doc = " Capacity is a performance hint for how many \"containers\" the data will need."]
    #[doc = " Can return false if auxiliary allocations fail when capacity greater than 0."]
    pub fn roaring_bitmap_init_with_capacity(r: *mut roaring_bitmap_t, cap: u32) -> bool;
}
extern "C" {
    #[doc = " Add all the values between min (included) and max (excluded) that are at a"]
    #[doc = " distance k*step from min."]
    pub fn roaring_bitmap_from_range(min: u64, max: u64, step: u32) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Creates a new bitmap from a pointer of uint32_t integers"]
    pub fn roaring_bitmap_of_ptr(n_args: size_t, vals: *const u32) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Describe the inner structure of the bitmap."]
    pub fn roaring_bitmap_printf_describe(r: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Creates a new bitmap from a list of uint32_t integers"]
    pub fn roaring_bitmap_of(n: size_t, ...) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Copies a bitmap (this does memory allocation)."]
    #[doc = " The caller is responsible for memory management."]
    pub fn roaring_bitmap_copy(r: *const roaring_bitmap_t) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Copies a bitmap from src to dest. It is assumed that the pointer dest"]
    #[doc = " is to an already allocated bitmap. The content of the dest bitmap is"]
    #[doc = " freed/deleted."]
    #[doc = ""]
    #[doc = " It might be preferable and simpler to call roaring_bitmap_copy except"]
    #[doc = " that roaring_bitmap_overwrite can save on memory allocations."]
    pub fn roaring_bitmap_overwrite(
        dest: *mut roaring_bitmap_t,
        src: *const roaring_bitmap_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Print the content of the bitmap."]
    pub fn roaring_bitmap_printf(r: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Computes the intersection between two bitmaps and returns new bitmap. The"]
    #[doc = " caller is responsible for memory management."]
    pub fn roaring_bitmap_and(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Computes the size of the intersection between two bitmaps."]
    pub fn roaring_bitmap_and_cardinality(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> u64;
}
extern "C" {
    #[doc = " Check whether two bitmaps intersect."]
    pub fn roaring_bitmap_intersect(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Check whether a bitmap and a closed range intersect."]
    pub fn roaring_bitmap_intersect_with_range(bm: *const roaring_bitmap_t, x: u64, y: u64)
        -> bool;
}
extern "C" {
    #[doc = " Computes the Jaccard index between two bitmaps. (Also known as the Tanimoto"]
    #[doc = " distance, or the Jaccard similarity coefficient)"]
    #[doc = ""]
    #[doc = " The Jaccard index is undefined if both bitmaps are empty."]
    pub fn roaring_bitmap_jaccard_index(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> f64;
}
extern "C" {
    #[doc = " Computes the size of the union between two bitmaps."]
    pub fn roaring_bitmap_or_cardinality(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> u64;
}
extern "C" {
    #[doc = " Computes the size of the difference (andnot) between two bitmaps."]
    pub fn roaring_bitmap_andnot_cardinality(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> u64;
}
extern "C" {
    #[doc = " Computes the size of the symmetric difference (xor) between two bitmaps."]
    pub fn roaring_bitmap_xor_cardinality(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> u64;
}
extern "C" {
    #[doc = " Inplace version of `roaring_bitmap_and()`, modifies r1"]
    #[doc = " r1 == r2 is allowed"]
    pub fn roaring_bitmap_and_inplace(r1: *mut roaring_bitmap_t, r2: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Computes the union between two bitmaps and returns new bitmap. The caller is"]
    #[doc = " responsible for memory management."]
    pub fn roaring_bitmap_or(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Inplace version of `roaring_bitmap_or(), modifies r1."]
    #[doc = " TODO: decide whether r1 == r2 ok"]
    pub fn roaring_bitmap_or_inplace(r1: *mut roaring_bitmap_t, r2: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Compute the union of 'number' bitmaps."]
    #[doc = " Caller is responsible for freeing the result."]
    #[doc = " See also `roaring_bitmap_or_many_heap()`"]
    pub fn roaring_bitmap_or_many(
        number: size_t,
        rs: *mut *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Compute the union of 'number' bitmaps using a heap. This can sometimes be"]
    #[doc = " faster than `roaring_bitmap_or_many() which uses a naive algorithm."]
    #[doc = " Caller is responsible for freeing the result."]
    pub fn roaring_bitmap_or_many_heap(
        number: u32,
        rs: *mut *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Computes the symmetric difference (xor) between two bitmaps"]
    #[doc = " and returns new bitmap. The caller is responsible for memory management."]
    pub fn roaring_bitmap_xor(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Inplace version of roaring_bitmap_xor, modifies r1, r1 != r2."]
    pub fn roaring_bitmap_xor_inplace(r1: *mut roaring_bitmap_t, r2: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Compute the xor of 'number' bitmaps."]
    #[doc = " Caller is responsible for freeing the result."]
    pub fn roaring_bitmap_xor_many(
        number: size_t,
        rs: *mut *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Computes the difference (andnot) between two bitmaps and returns new bitmap."]
    #[doc = " Caller is responsible for freeing the result."]
    pub fn roaring_bitmap_andnot(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Inplace version of roaring_bitmap_andnot, modifies r1, r1 != r2."]
    pub fn roaring_bitmap_andnot_inplace(r1: *mut roaring_bitmap_t, r2: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Frees the memory."]
    pub fn roaring_bitmap_free(r: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Add value n_args from pointer vals, faster than repeatedly calling"]
    #[doc = " `roaring_bitmap_add()`"]
    pub fn roaring_bitmap_add_many(r: *mut roaring_bitmap_t, n_args: size_t, vals: *const u32);
}
extern "C" {
    #[doc = " Add value x"]
    pub fn roaring_bitmap_add(r: *mut roaring_bitmap_t, x: u32);
}
extern "C" {
    #[doc = " Add value x"]
    #[doc = " Returns true if a new value was added, false if the value already existed."]
    pub fn roaring_bitmap_add_checked(r: *mut roaring_bitmap_t, x: u32) -> bool;
}
extern "C" {
    #[doc = " Add all values in range [min, max]"]
    pub fn roaring_bitmap_add_range_closed(r: *mut roaring_bitmap_t, min: u32, max: u32);
}
extern "C" {
    #[doc = " Remove value x"]
    pub fn roaring_bitmap_remove(r: *mut roaring_bitmap_t, x: u32);
}
extern "C" {
    #[doc = " Remove all values in range [min, max]"]
    pub fn roaring_bitmap_remove_range_closed(r: *mut roaring_bitmap_t, min: u32, max: u32);
}
extern "C" {
    #[doc = " Remove multiple values"]
    pub fn roaring_bitmap_remove_many(r: *mut roaring_bitmap_t, n_args: size_t, vals: *const u32);
}
extern "C" {
    #[doc = " Remove value x"]
    #[doc = " Returns true if a new value was removed, false if the value was not existing."]
    pub fn roaring_bitmap_remove_checked(r: *mut roaring_bitmap_t, x: u32) -> bool;
}
extern "C" {
    #[doc = " Check if value is present"]
    pub fn roaring_bitmap_contains(r: *const roaring_bitmap_t, val: u32) -> bool;
}
extern "C" {
    #[doc = " Check whether a range of values from range_start (included)"]
    #[doc = " to range_end (excluded) is present"]
    pub fn roaring_bitmap_contains_range(
        r: *const roaring_bitmap_t,
        range_start: u64,
        range_end: u64,
    ) -> bool;
}
extern "C" {
    #[doc = " Get the cardinality of the bitmap (number of elements)."]
    pub fn roaring_bitmap_get_cardinality(r: *const roaring_bitmap_t) -> u64;
}
extern "C" {
    #[doc = " Returns the number of elements in the range [range_start, range_end)."]
    pub fn roaring_bitmap_range_cardinality(
        r: *const roaring_bitmap_t,
        range_start: u64,
        range_end: u64,
    ) -> u64;
}
extern "C" {
    #[doc = " Returns true if the bitmap is empty (cardinality is zero)."]
    pub fn roaring_bitmap_is_empty(r: *const roaring_bitmap_t) -> bool;
}
extern "C" {
    #[doc = " Empties the bitmap.  It will have no auxiliary allocations (so if the bitmap"]
    #[doc = " was initialized in client memory via roaring_bitmap_init(), then a call to"]
    #[doc = " roaring_bitmap_clear() would be enough to \"free\" it)"]
    pub fn roaring_bitmap_clear(r: *mut roaring_bitmap_t);
}
extern "C" {
    #[doc = " Convert the bitmap to an array, output in `ans`,"]
    #[doc = ""]
    #[doc = " Caller is responsible to ensure that there is enough memory allocated, e.g."]
    #[doc = ""]
    #[doc = "     ans = malloc(roaring_bitmap_get_cardinality(bitmap) * sizeof(uint32_t));"]
    pub fn roaring_bitmap_to_uint32_array(r: *const roaring_bitmap_t, ans: *mut u32);
}
extern "C" {
    #[doc = " Convert the bitmap to an array from `offset` by `limit`, output in `ans`."]
    #[doc = ""]
    #[doc = " Caller is responsible to ensure that there is enough memory allocated, e.g."]
    #[doc = ""]
    #[doc = "     ans = malloc(roaring_bitmap_get_cardinality(limit) * sizeof(uint32_t));"]
    #[doc = ""]
    #[doc = " Return false in case of failure (e.g., insufficient memory)"]
    pub fn roaring_bitmap_range_uint32_array(
        r: *const roaring_bitmap_t,
        offset: size_t,
        limit: size_t,
        ans: *mut u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Remove run-length encoding even when it is more space efficient."]
    #[doc = " Return whether a change was applied."]
    pub fn roaring_bitmap_remove_run_compression(r: *mut roaring_bitmap_t) -> bool;
}
extern "C" {
    #[doc = " Convert array and bitmap containers to run containers when it is more"]
    #[doc = " efficient; also convert from run containers when more space efficient."]
    #[doc = ""]
    #[doc = " Returns true if the result has at least one run container."]
    #[doc = " Additional savings might be possible by calling `shrinkToFit()`."]
    pub fn roaring_bitmap_run_optimize(r: *mut roaring_bitmap_t) -> bool;
}
extern "C" {
    #[doc = " If needed, reallocate memory to shrink the memory usage."]
    #[doc = " Returns the number of bytes saved."]
    pub fn roaring_bitmap_shrink_to_fit(r: *mut roaring_bitmap_t) -> size_t;
}
extern "C" {
    #[doc = " Write the bitmap to an output pointer, this output buffer should refer to"]
    #[doc = " at least `roaring_bitmap_size_in_bytes(r)` allocated bytes."]
    #[doc = ""]
    #[doc = " See `roaring_bitmap_portable_serialize()` if you want a format that's"]
    #[doc = " compatible with Java and Go implementations.  This format can sometimes be"]
    #[doc = " more space efficient than the portable form, e.g. when the data is sparse."]
    #[doc = ""]
    #[doc = " Returns how many bytes written, should be `roaring_bitmap_size_in_bytes(r)`."]
    pub fn roaring_bitmap_serialize(
        r: *const roaring_bitmap_t,
        buf: *mut ::std::os::raw::c_char,
    ) -> size_t;
}
extern "C" {
    #[doc = " Use with `roaring_bitmap_serialize()`."]
    #[doc = ""]
    #[doc = " (See `roaring_bitmap_portable_deserialize()` if you want a format that's"]
    #[doc = " compatible with Java and Go implementations)"]
    pub fn roaring_bitmap_deserialize(buf: *const ::std::os::raw::c_void) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " How many bytes are required to serialize this bitmap (NOT compatible"]
    #[doc = " with Java and Go versions)"]
    pub fn roaring_bitmap_size_in_bytes(r: *const roaring_bitmap_t) -> size_t;
}
extern "C" {
    #[doc = " Read bitmap from a serialized buffer."]
    #[doc = " In case of failure, NULL is returned."]
    #[doc = ""]
    #[doc = " This function is unsafe in the sense that if there is no valid serialized"]
    #[doc = " bitmap at the pointer, then many bytes could be read, possibly causing a"]
    #[doc = " buffer overflow.  See also roaring_bitmap_portable_deserialize_safe()."]
    #[doc = ""]
    #[doc = " This is meant to be compatible with the Java and Go versions:"]
    #[doc = " https://github.com/RoaringBitmap/RoaringFormatSpec"]
    pub fn roaring_bitmap_portable_deserialize(
        buf: *const ::std::os::raw::c_char,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Read bitmap from a serialized buffer safely (reading up to maxbytes)."]
    #[doc = " In case of failure, NULL is returned."]
    #[doc = ""]
    #[doc = " This is meant to be compatible with the Java and Go versions:"]
    #[doc = " https://github.com/RoaringBitmap/RoaringFormatSpec"]
    pub fn roaring_bitmap_portable_deserialize_safe(
        buf: *const ::std::os::raw::c_char,
        maxbytes: size_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " Check how many bytes would be read (up to maxbytes) at this pointer if there"]
    #[doc = " is a bitmap, returns zero if there is no valid bitmap."]
    #[doc = ""]
    #[doc = " This is meant to be compatible with the Java and Go versions:"]
    #[doc = " https://github.com/RoaringBitmap/RoaringFormatSpec"]
    pub fn roaring_bitmap_portable_deserialize_size(
        buf: *const ::std::os::raw::c_char,
        maxbytes: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " How many bytes are required to serialize this bitmap."]
    #[doc = ""]
    #[doc = " This is meant to be compatible with the Java and Go versions:"]
    #[doc = " https://github.com/RoaringBitmap/RoaringFormatSpec"]
    pub fn roaring_bitmap_portable_size_in_bytes(r: *const roaring_bitmap_t) -> size_t;
}
extern "C" {
    #[doc = " Write a bitmap to a char buffer.  The output buffer should refer to at least"]
    #[doc = " `roaring_bitmap_portable_size_in_bytes(r)` bytes of allocated memory."]
    #[doc = ""]
    #[doc = " Returns how many bytes were written which should match"]
    #[doc = " `roaring_bitmap_portable_size_in_bytes(r)`."]
    #[doc = ""]
    #[doc = " This is meant to be compatible with the Java and Go versions:"]
    #[doc = " https://github.com/RoaringBitmap/RoaringFormatSpec"]
    pub fn roaring_bitmap_portable_serialize(
        r: *const roaring_bitmap_t,
        buf: *mut ::std::os::raw::c_char,
    ) -> size_t;
}
extern "C" {
    #[doc = " Returns number of bytes required to serialize bitmap using frozen format."]
    pub fn roaring_bitmap_frozen_size_in_bytes(r: *const roaring_bitmap_t) -> size_t;
}
extern "C" {
    #[doc = " Serializes bitmap using frozen format."]
    #[doc = " Buffer size must be at least roaring_bitmap_frozen_size_in_bytes()."]
    pub fn roaring_bitmap_frozen_serialize(
        r: *const roaring_bitmap_t,
        buf: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Creates constant bitmap that is a view of a given buffer."]
    #[doc = " Buffer data should have been written by `roaring_bitmap_frozen_serialize()`"]
    #[doc = " Its beginning must also be aligned by 32 bytes."]
    #[doc = " Length must be equal exactly to `roaring_bitmap_frozen_size_in_bytes()`."]
    #[doc = " In case of failure, NULL is returned."]
    #[doc = ""]
    #[doc = " Bitmap returned by this function can be used in all readonly contexts."]
    #[doc = " Bitmap must be freed as usual, by calling roaring_bitmap_free()."]
    #[doc = " Underlying buffer must not be freed or modified while it backs any bitmaps."]
    pub fn roaring_bitmap_frozen_view(
        buf: *const ::std::os::raw::c_char,
        length: size_t,
    ) -> *const roaring_bitmap_t;
}
extern "C" {
    #[doc = " Iterate over the bitmap elements. The function iterator is called once for"]
    #[doc = " all the values with ptr (can be NULL) as the second parameter of each call."]
    #[doc = ""]
    #[doc = " `roaring_iterator` is simply a pointer to a function that returns bool"]
    #[doc = " (true means that the iteration should continue while false means that it"]
    #[doc = " should stop), and takes (uint32_t,void*) as inputs."]
    #[doc = ""]
    #[doc = " Returns true if the roaring_iterator returned true throughout (so that all"]
    #[doc = " data points were necessarily visited)."]
    #[doc = ""]
    #[doc = " Iteration is ordered: from the smallest to the largest elements."]
    pub fn roaring_iterate(
        r: *const roaring_bitmap_t,
        iterator: roaring_iterator,
        ptr: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn roaring_iterate64(
        r: *const roaring_bitmap_t,
        iterator: roaring_iterator64,
        high_bits: u64,
        ptr: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if the two bitmaps contain the same elements."]
    pub fn roaring_bitmap_equals(r1: *const roaring_bitmap_t, r2: *const roaring_bitmap_t) -> bool;
}
extern "C" {
    #[doc = " Return true if all the elements of r1 are also in r2."]
    pub fn roaring_bitmap_is_subset(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Return true if all the elements of r1 are also in r2, and r2 is strictly"]
    #[doc = " greater than r1."]
    pub fn roaring_bitmap_is_strict_subset(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> bool;
}
extern "C" {
    #[doc = " (For expert users who seek high performance.)"]
    #[doc = ""]
    #[doc = " Computes the union between two bitmaps and returns new bitmap. The caller is"]
    #[doc = " responsible for memory management."]
    #[doc = ""]
    #[doc = " The lazy version defers some computations such as the maintenance of the"]
    #[doc = " cardinality counts. Thus you must call `roaring_bitmap_repair_after_lazy()`"]
    #[doc = " after executing \"lazy\" computations."]
    #[doc = ""]
    #[doc = " It is safe to repeatedly call roaring_bitmap_lazy_or_inplace on the result."]
    #[doc = ""]
    #[doc = " `bitsetconversion` is a flag which determines whether container-container"]
    #[doc = " operations force a bitset conversion."]
    pub fn roaring_bitmap_lazy_or(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
        bitsetconversion: bool,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " (For expert users who seek high performance.)"]
    #[doc = ""]
    #[doc = " Inplace version of roaring_bitmap_lazy_or, modifies r1."]
    #[doc = ""]
    #[doc = " `bitsetconversion` is a flag which determines whether container-container"]
    #[doc = " operations force a bitset conversion."]
    pub fn roaring_bitmap_lazy_or_inplace(
        r1: *mut roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
        bitsetconversion: bool,
    );
}
extern "C" {
    #[doc = " (For expert users who seek high performance.)"]
    #[doc = ""]
    #[doc = " Execute maintenance on a bitmap created from `roaring_bitmap_lazy_or()`"]
    #[doc = " or modified with `roaring_bitmap_lazy_or_inplace()`."]
    pub fn roaring_bitmap_repair_after_lazy(r1: *mut roaring_bitmap_t);
}
extern "C" {
    #[doc = " Computes the symmetric difference between two bitmaps and returns new bitmap."]
    #[doc = " The caller is responsible for memory management."]
    #[doc = ""]
    #[doc = " The lazy version defers some computations such as the maintenance of the"]
    #[doc = " cardinality counts. Thus you must call `roaring_bitmap_repair_after_lazy()`"]
    #[doc = " after executing \"lazy\" computations."]
    #[doc = ""]
    #[doc = " It is safe to repeatedly call `roaring_bitmap_lazy_xor_inplace()` on"]
    #[doc = " the result."]
    pub fn roaring_bitmap_lazy_xor(
        r1: *const roaring_bitmap_t,
        r2: *const roaring_bitmap_t,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " (For expert users who seek high performance.)"]
    #[doc = ""]
    #[doc = " Inplace version of roaring_bitmap_lazy_xor, modifies r1. r1 != r2"]
    pub fn roaring_bitmap_lazy_xor_inplace(r1: *mut roaring_bitmap_t, r2: *const roaring_bitmap_t);
}
extern "C" {
    #[doc = " Compute the negation of the bitmap in the interval [range_start, range_end)."]
    #[doc = " The number of negated values is range_end - range_start."]
    #[doc = " Areas outside the range are passed through unchanged."]
    pub fn roaring_bitmap_flip(
        r1: *const roaring_bitmap_t,
        range_start: u64,
        range_end: u64,
    ) -> *mut roaring_bitmap_t;
}
extern "C" {
    #[doc = " compute (in place) the negation of the roaring bitmap within a specified"]
    #[doc = " interval: [range_start, range_end). The number of negated values is"]
    #[doc = " range_end - range_start."]
    #[doc = " Areas outside the range are passed through unchanged."]
    pub fn roaring_bitmap_flip_inplace(r1: *mut roaring_bitmap_t, range_start: u64, range_end: u64);
}
extern "C" {
    #[doc = " Selects the element at index 'rank' where the smallest element is at index 0."]
    #[doc = " If the size of the roaring bitmap is strictly greater than rank, then this"]
    #[doc = " function returns true and sets element to the element of given rank."]
    #[doc = " Otherwise, it returns false."]
    pub fn roaring_bitmap_select(r: *const roaring_bitmap_t, rank: u32, element: *mut u32) -> bool;
}
extern "C" {
    #[doc = " roaring_bitmap_rank returns the number of integers that are smaller or equal"]
    #[doc = " to x. Thus if x is the first element, this function will return 1. If"]
    #[doc = " x is smaller than the smallest element, this function will return 0."]
    #[doc = ""]
    #[doc = " The indexing convention differs between roaring_bitmap_select and"]
    #[doc = " roaring_bitmap_rank: roaring_bitmap_select refers to the smallest value"]
    #[doc = " as having index 0, whereas roaring_bitmap_rank returns 1 when ranking"]
    #[doc = " the smallest value."]
    pub fn roaring_bitmap_rank(r: *const roaring_bitmap_t, x: u32) -> u64;
}
extern "C" {
    #[doc = " Returns the smallest value in the set, or UINT32_MAX if the set is empty."]
    pub fn roaring_bitmap_minimum(r: *const roaring_bitmap_t) -> u32;
}
extern "C" {
    #[doc = " Returns the greatest value in the set, or 0 if the set is empty."]
    pub fn roaring_bitmap_maximum(r: *const roaring_bitmap_t) -> u32;
}
extern "C" {
    #[doc = " (For advanced users.)"]
    #[doc = ""]
    #[doc = " Collect statistics about the bitmap, see roaring_types.h for"]
    #[doc = " a description of roaring_statistics_t"]
    pub fn roaring_bitmap_statistics(r: *const roaring_bitmap_t, stat: *mut roaring_statistics_t);
}
#[doc = " What follows is code use to iterate through values in a roaring bitmap"]
#[doc = ""]
#[doc = "roaring_bitmap_t *r =..."]
#[doc = "roaring_uint32_iterator_t i;"]
#[doc = "roaring_create_iterator(r, &i);"]
#[doc = "while(i.has_value) {"]
#[doc = "printf(\"value = %d\\n\", i.current_value);"]
#[doc = "roaring_advance_uint32_iterator(&i);"]
#[doc = "}"]
#[doc = ""]
#[doc = "Obviously, if you modify the underlying bitmap, the iterator"]
#[doc = "becomes invalid. So don't."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct roaring_uint32_iterator_s {
    pub parent: *const roaring_bitmap_t,
    pub container_index: i32,
    pub in_container_index: i32,
    pub run_index: i32,
    pub current_value: u32,
    pub has_value: bool,
    pub container: *const ::std::os::raw::c_void,
    pub typecode: u8,
    pub highbits: u32,
}
#[test]
fn bindgen_test_layout_roaring_uint32_iterator_s() {
    assert_eq!(
        ::std::mem::size_of::<roaring_uint32_iterator_s>(),
        48usize,
        concat!("Size of: ", stringify!(roaring_uint32_iterator_s))
    );
    assert_eq!(
        ::std::mem::align_of::<roaring_uint32_iterator_s>(),
        8usize,
        concat!("Alignment of ", stringify!(roaring_uint32_iterator_s))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<roaring_uint32_iterator_s>())).parent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_uint32_iterator_s),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<roaring_uint32_iterator_s>())).container_index as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_uint32_iterator_s),
            "::",
            stringify!(container_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<roaring_uint32_iterator_s>())).in_container_index as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_uint32_iterator_s),
            "::",
            stringify!(in_container_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<roaring_uint32_iterator_s>())).run_index as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_uint32_iterator_s),
            "::",
            stringify!(run_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<roaring_uint32_iterator_s>())).current_value as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_uint32_iterator_s),
            "::",
            stringify!(current_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<roaring_uint32_iterator_s>())).has_value as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_uint32_iterator_s),
            "::",
            stringify!(has_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<roaring_uint32_iterator_s>())).container as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_uint32_iterator_s),
            "::",
            stringify!(container)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<roaring_uint32_iterator_s>())).typecode as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_uint32_iterator_s),
            "::",
            stringify!(typecode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<roaring_uint32_iterator_s>())).highbits as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(roaring_uint32_iterator_s),
            "::",
            stringify!(highbits)
        )
    );
}
#[doc = " What follows is code use to iterate through values in a roaring bitmap"]
#[doc = ""]
#[doc = "roaring_bitmap_t *r =..."]
#[doc = "roaring_uint32_iterator_t i;"]
#[doc = "roaring_create_iterator(r, &i);"]
#[doc = "while(i.has_value) {"]
#[doc = "printf(\"value = %d\\n\", i.current_value);"]
#[doc = "roaring_advance_uint32_iterator(&i);"]
#[doc = "}"]
#[doc = ""]
#[doc = "Obviously, if you modify the underlying bitmap, the iterator"]
#[doc = "becomes invalid. So don't."]
pub type roaring_uint32_iterator_t = roaring_uint32_iterator_s;
extern "C" {
    #[doc = " Initialize an iterator object that can be used to iterate through the"]
    #[doc = " values. If there is a  value, then this iterator points to the first value"]
    #[doc = " and `it->has_value` is true. The value is in `it->current_value`."]
    pub fn roaring_init_iterator(r: *const roaring_bitmap_t, newit: *mut roaring_uint32_iterator_t);
}
extern "C" {
    #[doc = " Initialize an iterator object that can be used to iterate through the"]
    #[doc = " values. If there is a value, then this iterator points to the last value"]
    #[doc = " and `it->has_value` is true. The value is in `it->current_value`."]
    pub fn roaring_init_iterator_last(
        r: *const roaring_bitmap_t,
        newit: *mut roaring_uint32_iterator_t,
    );
}
extern "C" {
    #[doc = " Create an iterator object that can be used to iterate through the values."]
    #[doc = " Caller is responsible for calling `roaring_free_iterator()`."]
    #[doc = ""]
    #[doc = " The iterator is initialized (this function calls `roaring_init_iterator()`)"]
    #[doc = " If there is a value, then this iterator points to the first value and"]
    #[doc = " `it->has_value` is true.  The value is in `it->current_value`."]
    pub fn roaring_create_iterator(r: *const roaring_bitmap_t) -> *mut roaring_uint32_iterator_t;
}
extern "C" {
    #[doc = " Advance the iterator. If there is a new value, then `it->has_value` is true."]
    #[doc = " The new value is in `it->current_value`. Values are traversed in increasing"]
    #[doc = " orders. For convenience, returns `it->has_value`."]
    pub fn roaring_advance_uint32_iterator(it: *mut roaring_uint32_iterator_t) -> bool;
}
extern "C" {
    #[doc = " Decrement the iterator. If there's a new value, then `it->has_value` is true."]
    #[doc = " The new value is in `it->current_value`. Values are traversed in decreasing"]
    #[doc = " order. For convenience, returns `it->has_value`."]
    pub fn roaring_previous_uint32_iterator(it: *mut roaring_uint32_iterator_t) -> bool;
}
extern "C" {
    #[doc = " Move the iterator to the first value >= `val`. If there is a such a value,"]
    #[doc = " then `it->has_value` is true. The new value is in `it->current_value`."]
    #[doc = " For convenience, returns `it->has_value`."]
    pub fn roaring_move_uint32_iterator_equalorlarger(
        it: *mut roaring_uint32_iterator_t,
        val: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Creates a copy of an iterator."]
    #[doc = " Caller must free it."]
    pub fn roaring_copy_uint32_iterator(
        it: *const roaring_uint32_iterator_t,
    ) -> *mut roaring_uint32_iterator_t;
}
extern "C" {
    #[doc = " Free memory following `roaring_create_iterator()`"]
    pub fn roaring_free_uint32_iterator(it: *mut roaring_uint32_iterator_t);
}
extern "C" {
    pub fn roaring_read_uint32_iterator(
        it: *mut roaring_uint32_iterator_t,
        buf: *mut u32,
        count: u32,
    ) -> u32;
}
